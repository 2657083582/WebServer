## Linux多进程开发

### 一、进程概述

#### 1、进程和程序

（1）程序：程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：

- 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。

- 机器语言指令：对程序算法进行编码。

- 程序入口地址：表示程序开始执行时的起始指令位置。

- 数据：程序文件包含的变量初始值和程序使用的字面变量值。

- 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。

- 共享库和动态连接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。

- 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。

（2）进程：进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。他是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单位，也是基本的执行单位。

- 可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。
- 从内核的角度看，进程由用户内存空间和一系列内核数据成员组成，其中用户内核空间包含了程序代码及代码所用的变量，二内核数据结构则用于维护进程状态信息。
- 记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs)、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。

#### 2、单道、多道程序设计

1. 单道程序，即在计算机内存中只允许一个程序运行。
2. 多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，是他们在管理程序的控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态，这些程序共享计算机系统的资源。引入多道程序设计技术的根本目的是为了提高CPU的利用率。

- 对于一个单CPU系统来说，程序同时处于运行状态只是一种宏观的概念，他们虽然都已经开始运行，但就围观而言，任意时刻，CPU上运行的程序只有一个。
- 在多道程序设计模型中，多个进程轮流使用CPU。

#### 3、时间片

- 时间片（timeslice)又称为“量子”或“处理器片”,是操作系统分配给每个正在运行的进程微观上的一段CPU时间。
- 一段时间片通常为5 ms到800 ms。
- 时间片有操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。

#### 4、并行和并发

1. 并行（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行。
2. 并发（concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，是的宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分为若干段，是多个进程快速交替执行。

#### 5、进程控制块

为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux内核的进程控制块是task_struct 结构体。

task_struct结构体所在位置：/usr/src/linux-headers-xxx/include/linux/sched.h

task_struct中一些重要的成员：

- 进程id:系统中每个进程的唯一id,用pid_t类型表示，是一个非负整数
- 进程状态：包括就绪、运行、挂起、停止等状态
- 进程切换时需保存和恢复的一些CPU寄存器
- 描述虚拟地址空间的信息
- 描述控制终端的信息
- 当前工作目录
- umask掩码
- 文件描述符表，包含很多指向file结构体的指针
- 和信号相关的信息
- 用户id和组id
- 会话（Session）和进程组
- 进程可以使用的资源上限（Resource Limit)

### 二、进程状态转换

#### 1、进程的状态

- 进程的状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。

  - 三态模型：在三态模型中，进程状态分为三个基本状态，即就绪态、运行态、阻塞态。

    ![](D:\WebServer\NoteBook\第二章\image\进程的状态-三态模型.png)

    - 运行态：进程占有处理器正在运行

    - 就绪态：进程具备运行条件，等待系统分配处理器以便运行。

      当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可以立即执行。

      在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，成为就绪队列。			

    - 阻塞态：又称为等待态或睡眠态，之进程不具备运行条件，正在等待某个事件的完成。

  - 五态模型：包括新建态、就绪态、运行态、阻塞态和终止态

    ![](D:\WebServer\NoteBook\第二章\image\进程的状态-五态模型.png)

    - 新建态：进程刚被创建时的状态，尚未进入就绪队列

    - 终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。

      进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。	

      一旦其他进程完成了对终止态进程的信息抽取后，操作系统将删除该进程。

#### 2、进程相关的命令

1. 查看进程 

   - 命令 :ps

   ```shell
   ps aux / ajx
   ```

   ​	a:显示终端上的所有进程，包括其他用户的进程

   ​	u:显示进程的详细信息

   ​	x:显示没有控制终端的进程

   ​	j:列出与作业控制相关的信息

   - STAT参数意义

   | 参数 | 意义                              |
   | ---- | --------------------------------- |
   | D    | 不可中断                          |
   | R    | 正在运行，或在队列中的进程        |
   | S    | 处于休眠状态                      |
   | T    | 停止或被追踪                      |
   | Z    | 僵尸进程                          |
   | W    | 进入内存交换（从内核2.6开始无效） |
   | X    | 死掉的进程                        |
   | <    | 高优先级                          |
   | N    | 低优先级                          |
   | s    | 包含子进程                        |
   | +    | 位于前台的进程组                  |

2. 实时显示进程动态

   命令：top

   可以在使用top命令时加上 -d来指定显示信息更新的时间间隔，在top命令执行后，可以按以下按键对显示的结果进行排序：

   | 按键 | 排序方式                 |
   | ---- | ------------------------ |
   | M    | 根据内存使用量排序       |
   | P    | 根据CPU占有率排序        |
   | T    | 根据进程运行时间长短排序 |
   | U    | 根据用户名来筛选进程     |
   | K    | 输入指定的pid杀死进程    |

3. 杀死进程

   命令：kill

   ```shell
   kill [-signal] pid
   ```

   kill -l  列出所有信号

   kill -SIGKILL 进程ID

   kill -9 进程ID

   killall name 根据进程名杀死进程

#### 3、进程号和相关函数

- 每个进程都由进程号来标识，其类型为pid_t(整型)，进程好的范围：0~32767。

  每个进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。

- 任何进程（除init进程）都是由另一个进程创建，该进程为被创建进程的父进程，对应的进程号称为父进程号（PPID)。

- 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接受同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前进程号会当做当前的进程组号。

- 进程号和进程组相关函数：

  - ```c
    pid_t getpid(void);
    ```

  - ```c
    pid_t getppid(void);
    ```

  - ```c
    pid_t getpgid(pid_t pid);
    ```

### 三、进程创建

系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。

- fork函数

  ```c
  #include<sys/types.h>
  #include<unistd.h>
  
  pid_t fork(void);
  ```

  作用：用于创建子进程

  返回值：fork()会返回两次。一次是在父进程中，一次是在子进程中。

  - 成功：子进程中返回0，父进程中返回子进程ID
  - 失败：返回-1

  失败的两个主要原因：

  ​	1、当前系统的进程数已经达到了系统规定的上限，这是errno会被设置为EAGAIN

  ​	2、系统内存不足，这时errno会被设置为ENOMEN

利用fork函数创建子进程：

```c
#include<sys/types.h>
#include<unistd.h>
#include<stdio.h>

int main(){
    //创建子进程
    pid_t pid = fork();

    //判断是父进程还是子进程
    if(pid>0){
        //当前是父进程：返回值大于0，返回的是创建的子进程的进程号
        printf("pid:%d\n",pid);
        printf("I am parent process,pid:%d,ppid:%d\n",getpid(),getppid());
    }else if(pid==0){
        //当前是子进程：返回值为0
        printf("I am child process,pid:%d,ppid:%d\n",getpid(),getppid());
    }else{
        //创建失败：返回值为-1
        perror("fork");
        return -1;
    }

    for(int i=0;i<5;++i){
        printf("i:%d\n",i);
        sleep(1);
    }

    return 0;
}
```



