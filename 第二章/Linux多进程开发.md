## Linux多进程开发

### 一、进程概述

#### 1、进程和程序

（1）程序：程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：

- 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。

- 机器语言指令：对程序算法进行编码。

- 程序入口地址：表示程序开始执行时的起始指令位置。

- 数据：程序文件包含的变量初始值和程序使用的字面变量值。

- 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。

- 共享库和动态连接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。

- 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。

（2）进程：进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。他是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单位，也是基本的执行单位。

- 可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。
- 从内核的角度看，进程由用户内存空间和一系列内核数据成员组成，其中用户内核空间包含了程序代码及代码所用的变量，二内核数据结构则用于维护进程状态信息。
- 记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs)、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。

#### 2、单道、多道程序设计

1. 单道程序，即在计算机内存中只允许一个程序运行。
2. 多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，是他们在管理程序的控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态，这些程序共享计算机系统的资源。引入多道程序设计技术的根本目的是为了提高CPU的利用率。

- 对于一个单CPU系统来说，程序同时处于运行状态只是一种宏观的概念，他们虽然都已经开始运行，但就围观而言，任意时刻，CPU上运行的程序只有一个。
- 在多道程序设计模型中，多个进程轮流使用CPU。

#### 3、时间片

- 时间片（timeslice)又称为“量子”或“处理器片”,是操作系统分配给每个正在运行的进程微观上的一段CPU时间。
- 一段时间片通常为5 ms到800 ms。
- 时间片有操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。

#### 4、并行和并发

1. 并行（parallel）：指在同一时刻，有多条指令在多个处理器上同时执行。
2. 并发（concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，是的宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分为若干段，是多个进程快速交替执行。

#### 5、进程控制块

为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux内核的进程控制块是task_struct 结构体。

task_struct结构体所在位置：/usr/src/linux-headers-xxx/include/linux/sched.h

task_struct中一些重要的成员：

- 进程id:系统中每个进程的唯一id,用pid_t类型表示，是一个非负整数
- 进程状态：包括就绪、运行、挂起、停止等状态
- 进程切换时需保存和恢复的一些CPU寄存器
- 描述虚拟地址空间的信息
- 描述控制终端的信息
- 当前工作目录
- umask掩码
- 文件描述符表，包含很多指向file结构体的指针
- 和信号相关的信息
- 用户id和组id
- 会话（Session）和进程组
- 进程可以使用的资源上限（Resource Limit)

### 二、进程状态转换

#### 1、进程的状态

- 进程的状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。

  - 三态模型：在三态模型中，进程状态分为三个基本状态，即就绪态、运行态、阻塞态。

    ![](D:\WebServer\NoteBook\第二章\image\进程的状态-三态模型.png)

    - 运行态：进程占有处理器正在运行

    - 就绪态：进程具备运行条件，等待系统分配处理器以便运行。

      当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可以立即执行。

      在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，成为就绪队列。			

    - 阻塞态：又称为等待态或睡眠态，之进程不具备运行条件，正在等待某个事件的完成。

  - 五态模型：包括新建态、就绪态、运行态、阻塞态和终止态

    ![](D:\WebServer\NoteBook\第二章\image\进程的状态-五态模型.png)

    - 新建态：进程刚被创建时的状态，尚未进入就绪队列

    - 终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。

      进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。	

      一旦其他进程完成了对终止态进程的信息抽取后，操作系统将删除该进程。

#### 2、进程相关的命令

1. 查看进程 

   - 命令 :ps

   ```shell
   ps aux / ajx
   ```

   ​	a:显示终端上的所有进程，包括其他用户的进程

   ​	u:显示进程的详细信息

   ​	x:显示没有控制终端的进程

   ​	j:列出与作业控制相关的信息

   - STAT参数意义

   | 参数 | 意义                              |
   | ---- | --------------------------------- |
   | D    | 不可中断                          |
   | R    | 正在运行，或在队列中的进程        |
   | S    | 处于休眠状态                      |
   | T    | 停止或被追踪                      |
   | Z    | 僵尸进程                          |
   | W    | 进入内存交换（从内核2.6开始无效） |
   | X    | 死掉的进程                        |
   | <    | 高优先级                          |
   | N    | 低优先级                          |
   | s    | 包含子进程                        |
   | +    | 位于前台的进程组                  |

2. 实时显示进程动态

   命令：top

   可以在使用top命令时加上 -d来指定显示信息更新的时间间隔，在top命令执行后，可以按以下按键对显示的结果进行排序：

   | 按键 | 排序方式                 |
   | ---- | ------------------------ |
   | M    | 根据内存使用量排序       |
   | P    | 根据CPU占有率排序        |
   | T    | 根据进程运行时间长短排序 |
   | U    | 根据用户名来筛选进程     |
   | K    | 输入指定的pid杀死进程    |

3. 杀死进程

   命令：kill

   ```shell
   kill [-signal] pid
   ```

   kill -l  列出所有信号

   kill -SIGKILL 进程ID

   kill -9 进程ID

   killall name 根据进程名杀死进程

#### 3、进程号和相关函数

- 每个进程都由进程号来标识，其类型为pid_t(整型)，进程好的范围：0~32767。

  每个进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。

- 任何进程（除init进程）都是由另一个进程创建，该进程为被创建进程的父进程，对应的进程号称为父进程号（PPID)。

- 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接受同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前进程号会当做当前的进程组号。

- 进程号和进程组相关函数：

  - ```c
    pid_t getpid(void);
    ```

  - ```c
    pid_t getppid(void);
    ```

  - ```c
    pid_t getpgid(pid_t pid);
    ```

#### 4、进程创建

系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。

- fork函数

  ```c
  #include<sys/types.h>
  #include<unistd.h>
  
  pid_t fork(void);
  ```

  作用：用于创建子进程

  返回值：fork()会返回两次。一次是在父进程中，一次是在子进程中。

  - 成功：子进程中返回0，父进程中返回子进程ID
  - 失败：返回-1

  失败的两个主要原因：

  ​	1、当前系统的进程数已经达到了系统规定的上限，这是errno会被设置为EAGAIN

  ​	2、系统内存不足，这时errno会被设置为ENOMEN

利用fork函数创建子进程：

```c
#include<sys/types.h>
#include<unistd.h>
#include<stdio.h>

int main(){
    //创建子进程
    pid_t pid = fork();

    //判断是父进程还是子进程
    if(pid>0){
        //当前是父进程：返回值大于0，返回的是创建的子进程的进程号
        printf("pid:%d\n",pid);
        printf("I am parent process,pid:%d,ppid:%d\n",getpid(),getppid());
    }else if(pid==0){
        //当前是子进程：返回值为0
        printf("I am child process,pid:%d,ppid:%d\n",getpid(),getppid());
    }else{
        //创建失败：返回值为-1
        perror("fork");
        return -1;
    }

    for(int i=0;i<5;++i){
        printf("i:%d\n",i);
        sleep(1);
    }

    return 0;
}
```

#### 5、父子进程虚拟地址空间情况

实际上，Linux的fork()使用是通过写时拷贝（copy-on-write)实现。

写时拷贝是一种可以推迟甚至避免拷贝数据的技术。

内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。

只用在需要写入的时候才会复制地址空间，从而使各个进程拥有各自的地址空间。

也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读的方式共享。

注意：fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。

#### 6、父子进程关系及GDB多进程调试

1. 父子进程之间的关系

   - 区别：

     - fork()函数的返回值不同

       ​	父进程中，返回子进程的ID

       ​	子进程中，返回值为0

     - PCB中的一些数据不同

       ​	当前进程的id、pid

       ​	当前进程的父进程的id、pid

       ​	信号集

   - 共同点：

     - 某些状态下（子进程刚被创建出来，还没有执行任何写数据的操作时），以下信息相同:

       ​	-用户区的数据

     ​		   -文件描述符表

2. 父子进程对变量是不是共享的？

   - **读时共享**：子进程被创建，两个进程都没有做任何写的操作时是共享的。
   - **写时拷贝**：只有当某个进程进行写操作时，内核才会为进程复制资源，分配独立的空间。

3. GDB多进程调试

   - 使用GDB调试的时候，GDB默认只能跟踪一个进程，默认是跟踪父进程。可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或子进程。

     - 设置调试父进程或者子进程：```set follow-fork-mode [parent(默认) | child]```

     - 设置调试模式：```set detach-on-fork [on | off]```

       默认为on,表示调试当前进程的时候，其他进程继续运行；

       如果为off，调试当前进程的时候，其他进程被GDB挂起。

     - 查看调试的进程：```info inferiors```
     - 切换当前调试的进程：```inferior num```
     - 使进程脱离GDB调试：```detach inferiors num```

### 三、exec函数族

#### 1、exec函数族介绍

- exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。

- exec函数族的函数执行成功后不会返回。因为调用进程的实体，包括代码段、数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息。只有函数调用失败了，它们才会返回-1，从原程序的调用点从上往下执行。

#### 2、exec函数族

![](D:\WebServer\NoteBook\第二章\image\exec函数族.png)

1. execl

   ```c
   #include<unistd.h>
   
   int execl(const char *path,const char *arg,...);
   ```

   - 参数：

     ​	-path:需要指定的执行的文件的路径或名称（推荐使用绝对路径）

     ​	-arg:是执行可执行文件所需要的参数列表

     ​			第一个参数一般没有什么作用，为了方便面，一般写的是执行的程序的名称。

     ​			从第二个参数开始往后，就是程序执行所需要的参数列表。

     ​			参数最后需要以NULL结束（哨兵)

   - 返回值：

     ​	失败：返回-1,并设置errno

     ​	成功：没有返回值

     

2. execlp：会到环境变量中查找指定的可执行文件，如果找到就执行，找不到就执行不成功

   ```c
   #include<unistd.h>
   
   int execl(const char *file,const char *arg,...);
   ```

   - 参数：

     ​	-file:需要指定的执行的文件名

     ​	-arg:是执行可执行文件所需要的参数列表

     ​			第一个参数一般没有什么作用，为了方便面，一般写的是执行的程序的名称。

     ​			从第二个参数开始往后，就是程序执行所需要的参数列表。

     ​			参数最后需要以NULL结束（哨兵)

   - 返回值：

     ​	失败：返回-1,并设置errno

     ​	成功：没有返回值

     

3. execv

   ```c
   #include<unistd.h>
   
   int execl(const char *path,const char *argv[]);
   ```

   argv是需要的参数的一个字符串数组，例如：

   ```c
   char *argv[]={"ps","aux",NULL};
   execv("/bin/ps",argv);
   ```

   

### 四、进程控制

#### 1、进程退出

- 进程退出流程

![进程退出流程](D:\WebServer\NoteBook\第二章\image\进程退出.png)

- exit函数和_exit函数

  - exit：标准C库进程退出函数

    ```c
    #include<stdlib.h>
    
    void exit(int status);
    ```

  - _exit： Linux系统调用，进程退出函数

    ```c
    #include<unistd.h>
    void _exit(int status);
    ```

    - 参数：-status:是进程退出时的一个状态信息。父进程回收子进程资源时可以获取到。

    注意：exit函数会先刷新I/O缓冲区并关闭文件描述符，再调用系统_exit函数；

    ​			而_exit函数不会刷新缓冲区。

    举个简单的例子：

    代码一：

    ```c
    #include<stdlib.h>
    #include<stdio.h>
    #include<unistd.h>
    
    int main(){
    	printf("hello\n");
    	printf("world");
    	
    	exit(0);
    }
    //程序执行结果：hello\nworld
    ```

    代码二：

    ```c
    #include<stdlib.h>
    #include<stdio.h>
    #include<unistd.h>
    
    int main(){
    	printf("hello\n");
    	printf("world");
    	
    	_exit(0);
    }
    //程序执行结果：hello
    ```

    分析：printf()函数属于C标准输出函数，它会将内容先保存到缓冲区。

    ​			第一次调用printf函数后有一个换行符，换行符会刷新缓冲区，此时输出hello；

    ​			而第二次调用printf函数时没有换行符，因此缓冲区并不会被刷新，那么world还在缓冲区中，此时：

    ​		针对代码一：调用exit函数，会刷新缓冲区，输出world,然后调用系统的_exit函数，程序退出；

    ​		针对代码二：调用_exit函数，不会刷新缓冲区，程序直接退出，缓冲区中的内容被释放，因此不会输出world。

#### 2、孤儿进程（Orphan Process)

- 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程。
- 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init,而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程结束生命周期时，init进程就会为其做善后工作。因此，孤儿进程并不会有什么危害。

		#### 3、僵尸进程（Zombie Process)

- 每个进程结束后，都会释放自己地址空间中的用户数据，内核区的PCB没有办法自己释放掉，需要父进程去释放。
- 进程终止时，父进程尚未回收，子进程残留资源（PCB)仍存放在内核中，就会变成僵尸进程。
- 僵尸进程不能被kill -9命令杀死。
- 系统的进程号时有限的，而僵尸进程的进程号不会被释放，那么，如果有大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即僵尸进程的危害，应当避免。

#### 4、进程回收

- 每个进程退出时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等。但是仍会为其保留一些信息（主要是进程控制块PCB的信息，包括进程号、退出状态、运行时间等）。

- 父进程可以通过调用wait和waitpid得到他的退出状态同时彻底清除这个进程。

  wait()和waitpid()功能一样，区别在于：

  ​	wait函数会阻塞；

  ​	waitpid函数可以设置不阻塞，还能指定等待哪个子进程结束。

​		注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。

1. wait函数

   ```c
   #include<sys/types.h>
   #include<sys/wait.h>
   
   pit_t wait(int *wstatus);
   ```

   - 功能:等待任意一个子进程结束，如果任意一个子进程结束，此函数会回收子进程的资源。

     调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽略的信号。

   - 参数：-wstatus:进程退出的状态信息你，传入的是一个int类型的地址，传出参数。

     退出信息相关的宏函数：

     | 宏函数               | 含义                                         |
     | -------------------- | -------------------------------------------- |
     | WIFEXITED(status)    | 非0，程序正常退出                            |
     | WEXITSTATUS(status)  | 如果宏为真，获取进程退出的状态（exit的参数） |
     | WIFSIGNALED(status)  | 非0，进程异常终止                            |
     | WTERMSIG(status)     | 如果宏为真，获取进程终止的信号编号           |
     | WIFSTOPPED(status)   | 非0，进程处于暂停状态                        |
     | WSTOPSIG(status)     | 如果宏为真，获取使进程暂停的信号编号         |
     | WIFCONTINUED(status) | 非0，进程暂停后已经继续运行                  |

   - 返回值：

     - 成功：返回被回收的子进程的id
     - 失败：返回-1（所有子进程都结束，调用函数返回失败）

```C
#include<sys/types.h>
#include<sys/wait.h>
#include<unistd.h>
#include<stdio.h>

int main(){

    //有一个父进程，创建了5个子进程（兄弟）

    pid_t pid;

    for(int i=0;i<5;++i){
        pid=fork();
        if(pid==0){
            break;
        }
    }

    if(pid>0){
        //父进程
        while(1){
            printf("I am parent process,pid:%d\n",getpid());

            int ret=wait(NULL);
            printf("child die,pid:%d\n",ret);

            sleep(1);
        }
    }else if(pid==0){
        //子进程
        while(1){
            printf("I am child process,pid:%d\n",getpid());
            sleep(1);
        }
    }else{
        perror("fork");
        return -1;
    }

    return 0;
}
```



1. waitpid函数

   ```c
   #include<sys/types.h>
   #include<sys/wait.h>
   
   pit_t wait(pid_t pid,int *wstatus,int options);
   ```

   - 功能：回收指定进程号的子进程，可以设置是否阻塞

   - 参数：

     ​		-pid:

     | pid  | 含义                                               |
     | ---- | -------------------------------------------------- |
     | >0   | 某个子进程的pid                                    |
     | =0   | 回收当前进程组的所有子进程                         |
     | =-1  | 回收所有的子进程，相当于wait() 最常用()            |
     | <-1  | 某个进程组的组id的绝对值，回收指定进程组中的子进程 |

     ​		-wstatus:与wait中的wstatus相同

     ​		-options:设置阻塞或非阻塞

     ​				0：阻塞

     ​				WNOHANG:非阻塞

   - 返回值：

     ​		>0:返回子进程的id;

     ​		=0: options=WNOHANG,表示还有子进程没有退出

     ​		=-1:错误，或者没有子进程了



​	
